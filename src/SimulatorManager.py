import numpy as np
import scipy.signal
import math

from src.DelayLine import DelayLine
from src.Material import Material

class SimulatorManager:
    """
    This class defines the simulation logic. It contains all the methods and components that are needed
    to run the acoustic simulation in the defined scenario, and compute the output signals generated. The
    acoustic scene defined in the `Environment` module contains a single sound source, an array of microphones, 
    and some additional parameters (e.g. a sampling frequency, the air properties, the road surface properties,
    a background noise). The `SimulatorManager` simulates the propagation of sound from a moving source and a 
    single, static microphone, exploiting the scene parameters that it receives at the time of its initialization.

    The simulation aims at computing the signal received at the microphone as it is emitted by the sound source and
    reflected from the road surface. The received signal will contain two different components: the direct sound,
    propagating directly from the source (assumed to be omnidirectional and point-like) to the microphone (assumed
    to be omnidirectional and point-like too), and the sound reflected by the road surface. In order to simulate the
    reflection, the simulator exploits the Image-Source Method (ISM): a virtual source is generated by reflecting the
    position of the real sound source w.r.t the road surface, and the reflected sound is assumed to be generated by
    this source as if it was emitting in the free-field. The sound produced the image source is then filtered by a 
    set of FIR filters that simulate the asphalt surface absorption and the attenuation due to the propagation of
    the sound through the air.
    
    The simulation is divided in two separate phases:
    * During the `initialization` phase, the `DelayLine` components used to simulate the sound propagation delay
    are instantiated, and the initial delay between the microphone, the sound source and the reflection point is
    computed.
    * During the `update` phase, first the signal emitted by the source is written on the two `DelayLine` instances 
    controlling the direct and reflected sound propagation delays. Then, the delays are updated according to the 
    new position of the moving source, together with the distances source -> receiver, image source -> road surface 
    and road surface -> receiver. The corresponding delayed signal samples are read from the `DelayLines` and filtered
    via a set of filters simulating the (angle-dependent) asphalt reflection and the air-absorption. Finally, the
    signal received by the microphone is computed by summing the direct and the reflected components of the simulated
    sound field.

    Attributes
    -------
    c: float
        Speed of sound in the air
    fs: int
        Sampling frequency used in the simulations
    Z0: float
        Acoustic impedance of air
    road_material: Material
        Asphalt type of the road surface, defined by its absorption and reflection properties
    primaryDelayLine: DelayLine
        Primary `DelayLine` component, used to compute delays corresponding to propagation of sound between source
        and receiver on direct path, and between image source and road surface, on reflected path
    secondaryDelayLine: DelayLine
        Secondary `DelayLine` component, used to compute delay corresponding to the propagation of sound on the 
        reflected path from the reflection point on the road surface to the microphone position
    airAbsorptionCoefficients: np.ndarray
        1D array containing the air absorption coefficients computed in a set of frequency bands covering the 
        range from 0 to fs/2
    asphaltReflectionFilterTable: np.ndarray
        2D array containing the asphalt reflection filters computed at different reflection angles. The filters
        have a fixed number of taps ntaps = 10, and their impulse response at a set of angles from -89 to + 89 degrees
        is pre-computed and stored in this table in order to speed up the execution.

    Methods
    ------
    initialize(src_pos: np.ndarray, mic_pos: np.ndarray):
        Sets the initial delays in the primary and secondary delay lines, according to the (initial) position of the
        source and the position of the microphone used for the current simulation
    update(src_pos: np.ndarray, mic_pos: np.ndarray, signal_sample: float):
        Updates delays on the primary and secondary delay lines given the new position of the source, and produces
        a new sample received by the microphone
    """

    def __init__(
            self,
            c: float,                       # speed of sound in air 
            fs: int,                        # sampling frequency
            Z0: int,                      # characteristic impedance of air
            road_material: Material,        # Absorption properties of road surface
            airAbsorptionCoefficients: np.ndarray,
        ) -> None:
        """
        Creates a `SimulatorManager` object containing all the methods and attributes required to run the acoustic
        simulation. When the constructor is called, the environmental parameters previously defined in the object
        `Environment` are stored into the simulator manager (c, fs, Z0, road_material, airAbsorptionCoefficients). 
        In addition, the two `DelayLine` objects required for the simulation are instantiated as empty circular 
        arrays with 48000 entries. The `asphaltReflectionFilterTable` in pre-computed and stored as an instance 
        attribute containing the FIR filter coefficients that describe asphalt reflection at different angles of
        incidence of the sound wave emitted by the source. This will result in a reduction of the computational load,
        in that the computation of a new filter depending on the instantaneous incidence angle is changed into a 
        table lookup. The set of considered incidence angles is stored in `_theta_vector` in degrees.

        Finally, a set of auxiliary buffers are instantiated and will be used for filtering purpose, together with a
        read pointer to extract value from these buffers.

        Parameters
        ----------
        c : float
            _description_
        fs: int
            _description_
        Z0: float
            _description_
        road_material: Material
            _description_
        airAbsorptionCoefficients: np.ndarray
            _description_
        """
        self.c = c
        self.fs = fs
        self.Z0 = Z0
        self.road_material = road_material
        self.airAbsorptionCoefficients = airAbsorptionCoefficients

        # Instantiation of two delay lines used for the simulations
        self.primaryDelLine = DelayLine(N = 48000, num_read_ptrs = 2, interpolation = 'Sinc') 
        self.secondaryDelLine = DelayLine(N = 48000, num_read_ptrs = 1, interpolation = 'Sinc')

        # Array containing all possible incidence angles for pre-computed reflection filter table
        self._theta_vector = np.arange(-89,89,1)

        # Instantiation of table containing asphalt reflection filters
        self.asphaltReflectionFilterTable = self._compute_angle_reflection_table(ntaps = 11)
        
        # Buffers to store previous data read from delay lines for filtering purpose
        self._read1Buf = np.zeros(20)
        self._read2Buf = np.zeros(20)
        self._read3Buf = np.zeros(20)
        self._read4Buf = np.zeros(20)
        
        # Read Pointer on buffers -> same pointer for all buffers
        self._readBufPtr = 0

    def initialize(self, src_pos: np.ndarray, mic_pos: np.ndarray) -> None:
        """
        Computes the propagation delays along the paths:
        * Direct path from source initial position to microphone
        * Path from source initial position to incidence point on asphalt surface, along reflected path
        * Path from incidence point on asphalt surface to microphone, along reflected path
        and sets the corresponding initial delays on the two delay lines.

        This method must be called at the start of every simulation to set the initial conditions that
        ensure no discontinuity is generated at the first simulation instant.

        Parameters
        ----------
        src_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the initial position of the sound source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone
        """

        # Compute direct distance and delay
        _, tau = self._compute_delay(src_pos, mic_pos)
        
        # Compute incidence angle
        theta = self._compute_angle(src_pos, mic_pos)

        # Compute distance between src and reflection point
        a = src_pos[2] / np.sin(theta)
        tau_1 = a / self.c
        
        # Compute distance between reflection point and microphone
        b = src_pos[2] / np.sin(theta)
        tau_2 = b / self.c

        # Set initial delays
        self.primaryDelLine.set_delays(np.array([tau * self.fs, tau_1 * self.fs]))
        self.secondaryDelLine.set_delays(np.array([tau_2 * self.fs]))
        

    # Compute new delays given acutal positions of src and microphone.
    # Update coefficients of filters with new positions.
    # Produce output value.
    def update(self, src_pos: np.ndarray, mic_pos: np.ndarray, signal_sample: float) -> float:
        # Compute direct distance and delay
        d, tau = self._compute_delay(src_pos, mic_pos, self.c)

        # Compute incidence angle
        theta = self._compute_angle(src_pos, mic_pos)

        # Compute distance between src and reflection point
        a = src_pos[2] / np.sin(theta)
        tau_1 = a / self.c
        
        # Compute distance between reflection point and microphone
        b = mic_pos[2] / np.sin(theta)
        tau_2 = b / self.c

        # Update delays and get new sample reads
        y_primary = self.primaryDelLine.update_delay_line(signal_sample, np.array([tau * self.fs, 
            tau_1 * self.fs]))

        # Store the read samples in a circular array to be used for filtering with air abs and asphalt refl
        self._read1Buf = y_primary[0]
        self._read2Buf = y_primary[1]
        # self._read3Buf = y_secondary

        self._readBufPtr +=1
        if self._readBufPtr >= 20:
            self._readBufPtr -= 20
        
        ### DIRECT PATH ###

        # Attenuation due to distance
        att = self._compute_sound_attenuation(d)

        # Attenuation due to air absorption
        filt_coeffs = self._compute_air_absorption_filter(self.airAbsorptionCoefficients, d, numtaps = 11)
        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read1Buf[self._readBufPtr - ii] * filt_coeffs[ii]
        
        # Direct Path Output Sample
        y_dir =  att * sample_eval

        ### REFLECTED PATH ###

        # 1. From Source to Road Surface

        # Attenuation due to distance
        att = self._compute_sound_attenuation(a)
        
        # Attenuation due to air absorption
        filt_coeffs = self._compute_air_absorption_filter(self.airAbsorptionCoefficients, a, numtaps = 11)

        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read2Buf[self._readBufPtr - ii] * filt_coeffs[ii]
        sample_eval = att * sample_eval
        self._read3Buf[self._readBufPtr] = sample_eval

        # 2. Asphalt Absorption
        asphalt_filter_coeffs = self._get_asphalt_reflection_filter(90 - theta, 
            self.asphaltReflectionFilterTable, np.array([-89, 89]))
        
        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read3Buf[self._readBufPtr - ii] * asphalt_filter_coeffs[ii]
        
        
        # 3. Second path in air --> Secondary Delay Line
        y_secondary = self.primaryDelLine.update_delay_line(sample_eval, np.array([tau_2 * self.fs]))
        self._read4Buf[self._readBufPtr] = y_secondary
        # 4. From Road Surface to Receiver

        # Attenuation due to distance
        att = self._compute_sound_attenuation(b)

        # Attenuation due to air absorption
        # alpha = compute_air_absorption_coeffs(T, p_s, hrar, F)
        # alpha = 10 ** (-alpha * drefl / 20)     # Convert coeffs in dB to linear scale
        filt_coeffs = self._compute_air_absorption_filter(self.airAbsorptionCoefficients, b, numtaps = 11)

        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read4Buf[self._readBufPtr - ii] * filt_coeffs[ii]
        y_refl = att * sample_eval

        y_received = y_dir + y_refl

        return y_received
    
    def _compute_air_absorption_filter(self, distance: float, numtaps: int) -> np.ndarray:
        """
        Computes air absorption filter as a FIR filter with `numtaps` coefficients. The filter depends
        on the distance travelled by the sound wave between the source and the receiver.

        Parameters
        ----------
        distance : float
            Distance travelled by the sound wave, in meters
        numtaps : int
            Number of coefficients of the FIR filter

        Returns
        -------
        np.ndarray
            1D array containing `numtaps` FIR filter coefficients modelling air absorption
        """

        f = np.linspace(0, self.fs, num = 50)
        norm_freqs = f / max(f)
        alpha = 10 ** (-self.airAbsorptionCoefficients * distance / 20)     # Convert coeffs in dB to linear scale
        filt_coeffs = scipy.signal.firwin2(numtaps, norm_freqs, alpha)
        
        return filt_coeffs

    def _compute_angle_reflection_table(self, ntaps: int = 11) -> np.ndarray:
        """
        Computes the coefficients of the FIR filters modelling asphalt reflection, at a set of different sound wave 
        incidence angles, and stores them in a table. Each row of the table contains the `ntaps` FIR filter corresponding
        to a different incidence angle. The set of angles is defined in `self._theta_vector`.

        The filter coefficients are computed using the `scipy.signal.firwin2` method, given the reflection coefficients
        computed in the frequency bands `center_freqs`, defined in the instance attribute `road_material`. 
        The reflection coefficients are derived from the  absorption coefficients of the road surface, defined
        in the instance attribute `road_material`. The road surface is assumed to be  locally reactive, meaning 
        that its impedance Z does not depend on the incidence angle.

        Parameters
        ----------
        ntaps : int
            Number of FIR filter coefficients, must be odd

        Returns
        -------
        np.ndarray
            2D Array with len(self._theta_vector) rows, each containing `ntaps` FIR filter coefficients corresponding
            to each angle defined in `self._theta_vector`
        """
        
        Z0 = self.Z0
        refl = np.sqrt(1 - np.array(self.road_material.absorption["coeffs"]))
        
        # The impedance does not depend on the angle of incidence -> locally reactive surface
        Z = - Z0 * (refl + 1) / (refl-1)
        
        b_fir = np.zeros((len(self._theta_vector), ntaps))
        
        # Compute filters coefficients for all thetas
        for idx, theta in enumerate(self._theta_vector):
            # Absolute value is taken to prevent R from going below zero. 
            # In Kuttruff, "Acoustics - an Introduction" the modulus of R is used
            # to compute reflections, and with this procedure we are not computing the 
            # imaginary part (see Nijl et al. Absorbing surfaces... 2006), so the two approaches are coherent.
            R = np.abs((Z * np.cos(math.radians(theta)) - Z0) / (Z * np.cos(math.radians(theta)) + Z0))
            b_fir[idx] = scipy.signal.firwin2(ntaps, np.array(self.road_material.absorption["center_freqs"]) 
                / (self.fs/2), R)
        
        return b_fir
    
    def _get_asphalt_reflection_filter(self, theta: float) -> np.ndarray:
        """
        Select the asphalt reflection filter from the pre-computed table given the incidence angle of the 
        sound wave hitting the road surface, in degrees. For the table lookup, the incidence angle is 
        rounded to the closest integer in the range defined in `self._theta_vector` attribute.

        Parameters
        ----------
        theta : float
            Incidence angle of the sound wave hitting the road surface, in degrees

        Returns
        -------
        np.ndarray
            1D Array containing asphalt reflection filter coefficients computed at angle theta
        """

        idx = np.where(self._theta_vector == np.round(theta))
        idx = idx[0][0]
        return self.asphaltReflectionFilterTable[idx]

    def _compute_sound_attenuation(self, distance: float) -> float:
        """
        Computes the attenuation of sound due to its propagation in the empty space. This attenuation depends
        only on the distance between the source and the receiver and is computed assuming a spherical propagation
        model.

        Parameters
        ----------
        distance : float
            Relative distance between the sound source and the receiver

        Returns
        -------
        float
            Attenuation factor
        """
        return 1 / (4 * np.pi * distance)
    
    def _compute_delay(self, src_pos: np.ndarray, mic_pos: np.ndarray) -> tuple[float, float]:
        """
        Computes the distance between the source and the microphone, and the time needed by the sound to travel 
        from source to microphone, given their distance and the speed of sound in air.

        Parameters
        ----------
        src_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone

        Returns
        -------
        Tuple[float, float]
            Tuple containing the distance between source and microphone (in meters) and the time delay (in seconds)
        """

        d = np.sqrt(np.sum((src_pos - mic_pos)) ** 2)
        tau = d / self.c
        return d, tau
    
    def _compute_angle(self, src_pos: np.ndarray, mic_pos: np.ndarray) -> float:
        """
        Computes the incidence angle of the sound wave travelling from the source to the road surface, along the
        reflected path connecting the source to the microphone with a single reflection generated by the road.

        Parameters
        ----------
        src_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the source
        mic_pos : np.ndarray
            1D array containing the cartesian coordinates [x,y,z] denoting the position of the microphone

        Returns
        -------
        float
            Incidence angle of sound wave travelling from source to road surface along reflected path, in radians
        """

        # Distance between image and microphone
        dist = np.sqrt(np.sum(((src_pos - np.array([0, 0 , 2*src_pos[2]])) - mic_pos) ** 2))
        # Incidence angle
        theta = np.arcsin((src_pos[2] + mic_pos[2]) / dist)
        return theta