import numpy as np
import scipy.signal
import math

from src.DelayLine import DelayLine
from src.Material import Material
from src.SoundSource import SoundSource

class SimulatorManager:
    """
    This class defines the simulation logic. It contains all the methods and components that are needed
    to run the acoustic simulation in the defined scenario, and compute the output signals generated. The
    acoustic scene defined in the `Environment` module contains a single sound source, an array of microphones, 
    and some additional parameters (e.g. a sampling frequency, the air properties, the road surface properties,
    a background noise). The `SimulatorManager` simulates the propagation of sound from a moving source and a 
    single, static microphone, exploiting the scene parameters that it receives at the time of its initialization.

    The simulation aims at computing the signal received at the microphone as it is emitted by the sound source and
    reflected from the road surface. The received signal will contain two different components: the direct sound,
    propagating directly from the source (assumed to be omnidirectional and point-like) to the microphone (assumed
    to be omnidirectional and point-like too), and the sound reflected by the road surface. In order to simulate the
    reflection, the simulator exploits the Image-Source Method (ISM): a virtual source is generated by reflecting the
    position of the real sound source w.r.t the road surface, and the reflected sound is assumed to be generated by
    this source as if it was emitting in the free-field. The sound produced the image source is then filtered by a 
    set of FIR filters that simulate the asphalt surface absorption and the attenuation due to the propagation of
    the sound through the air.
    
    The simulation is divided in two separate phases:
    * During the `initialization` phase, the `DelayLine` components used to simulate the sound propagation delay
    are instantiated, and the initial delay between the microphone, the sound source and the reflection point is
    computed.
    * During the `update` phase, first the signal emitted by the source is written on the two `DelayLine` instances 
    controlling the direct and reflected sound propagation delays. Then, the delays are updated according to the 
    new position of the moving source, together with the distances source -> receiver, image source -> road surface 
    and road surface -> receiver. The corresponding delayed signal samples are read from the `DelayLines` and filtered
    via a set of filters simulating the (angle-dependent) asphalt reflection and the air-absorption. Finally, the
    signal received by the microphone is computed by summing the direct and the reflected components of the simulated
    sound field.

    Attributes
    -------
    c: float
        Speed of sound in the air
    fs: int
        Sampling frequency used in the simulations
    Z0: float
        Acoustic impedance of air
    road_material: Material
        Asphalt type of the road surface, defined by its absorption and reflection properties
    active_mic_pos: np.ndarray
        1D Array containing 3 [x,y,z] cartesian coordinates indicating the position of the microphone used for the
        current simulation
    source_pos: np.ndarray
        1D Array containing 3 [x,y,z] cartesian coordinates indicating the position of the sound source at the 
        current simulation instant
    primaryDelayLine: DelayLine
        Primary `DelayLine` component, used to compute delays corresponding to propagation of sound between source
        and receiver on direct path, and between image source and road surface, on reflected path
    secondaryDelayLine: DelayLine
        Secondary `DelayLine` component, used to compute delay corresponding to the propagation of sound on the 
        reflected path from the reflection point on the road surface to the microphone position
    airAbsorptionCoefficients: np.ndarray
        1D array containing the air absorption coefficients computed in a set of frequency bands covering the 
        range from 0 to fs/2
    asphaltReflectionFilterTable: np.ndarray
        2D array containing the asphalt reflection filters computed at different reflection angles. The filters
        have a fixed number of taps ntaps = 10, and their impulse response at a set of angles from -89 to + 89 degrees
        is pre-computed and stored in this table in order to speed up the execution.

    Methods
    ------
    initialize(src_pos: np.ndarray, mic_pos: np.ndarray):
        Sets the initial delays in the primary and secondary delay lines, according to the (initial) position of the
        source and the position of the microphone used for the current simulation
    update(src_pos: np.ndarray, mic_pos: np.ndarray, signal_sample: float):
        Updates delays on the primary and secondary delay lines given the new position of the source, and produces
        a new sample received by the microphone
    compute_air_absorption_filter(abs_coeffs: np.ndarray, distance: float, numtaps: int):
        Computes an air absorption FIR filter with `numtaps` taps, depending on the relative distance between
        the source and the microphone
    compute_angle_reflection_table(absorption_coeffs: np.ndarray, freqs: np.ndarray, ntaps: int):
        Computes the table containing the `ntaps`-taps FIR filters that model angle dependent asphalt absorption
        in a set of angles in the range [-89, 89] degrees.
    get_asphalt_reflection_filter(theta: float, b_fir: np.ndarray, theta_vector: np.ndarray):
        Retrieves the FIR filter corresponding to the asphalt reflection at angle `theta` from the pre-computed
        table
    """

    __instance = None
    _read1Buf = np.zeros(20)
    _read2Buf = np.zeros(20)
    _read3Buf = np.zeros(20)
    _read4Buf = np.zeros(20)
    _readBufPtr = 0

    @staticmethod
    def getInstance():
        if SimulatorManager.__instance == None:
            SimulatorManager()
        return SimulatorManager.__instance

    def __init__(
            self,
            c: float,                       # speed of sound in air 
            fs: int,                        # sampling frequency
            Z0: float,                      # characteristic impedance of air
            active_mic_pos: np.ndarray,     # position of active microphone
            road_material: Material,        # Absorption properties of road surface
            source_pos: SoundSource,            # Sound source emitting sound
            primaryDelLine: DelayLine,
            secondaryDelLine: DelayLine,
            airAbsorptionCoefficients: np.ndarray,
        ) -> None:
        if SimulatorManager.__instance != None:
            raise Exception("SimulatorManager already instantiated")
        else:
            SimulatorManager.__instance = self
        self.c = c
        self.fs = fs,
        self.Z0 = Z0,
        self.road_material = road_material
        self.active_mic_pos = active_mic_pos
        self.source_pos = source_pos
        self.primaryDelLine = primaryDelLine
        self.secondaryDelLine = secondaryDelLine
        self.airAbsorptionCoefficients = airAbsorptionCoefficients
        
        self.asphaltReflectionFilterTable = self.compute_angle_reflection_table(
            self.road_material.absorption["coeffs"], 
            self.road_material.absorption["center_freqs"], 
            ntaps = 10)

    # Compute initial delay and set it into the two delay lines. 
    # Compute air absorption filters and asphalt reflection filter and store the precomputed values in a table. 
    # Instantiate delay lines.
    def initialize(self, src_pos: np.ndarray, mic_pos: np.ndarray) -> None:
        self.primaryDelLine = DelayLine(N = 48000, write_ptr = 0, read_ptr = np.array([0,0]), fs = self.fs)
        self.secondaryDelLine = DelayLine(N = 48000, write_ptr = 0, read_ptr = np.array([0]), fs = self.fs)

        # Compute direct distance and delay
        d, tau = self._compute_delay(src_pos, mic_pos, self.c)
        
        # Compute incidence angle
        theta = self._compute_angle(src_pos, mic_pos)

        # Compute distance between src and reflection point
        a = src_pos[2] / np.sin(theta)
        tau_1 = a / self.c
        
        # Compute distance between reflection point and microphone
        b = src_pos[2] / np.sin(theta)
        tau_2 = b / self.c

        # Set initial delays
        self.primaryDelLine.set_delays(np.array([tau * self.fs, tau_1 * self.fs]))
        self.secondaryDelLine.set_delays(tau_2 * self.fs)
        

    # Compute new delays given acutal positions of src and microphone.
    # Update coefficients of filters with new positions.
    # Produce output value.
    def update(self, src_pos: np.ndarray, mic_pos: np.ndarray, signal_sample: float) -> float:
        # Compute direct distance and delay
        d, tau = self._compute_delay(src_pos, mic_pos, self.c)

        # Compute incidence angle
        theta = self._compute_angle(src_pos, mic_pos)

        # Compute distance between src and reflection point
        a = src_pos[2] / np.sin(theta)
        tau_1 = a / self.c
        
        # Compute distance between reflection point and microphone
        b = mic_pos[2] / np.sin(theta)
        tau_2 = b / self.c

        # Update delays and get new sample reads
        y_primary = self.primaryDelLine.update_delay_line(signal_sample, np.array([tau * self.fs, 
            tau_1 * self.fs]))

        # Store the read samples in a circular array to be used for filtering with air abs and asphalt refl
        self._read1Buf = y_primary[0]
        self._read2Buf = y_primary[1]
        # self._read3Buf = y_secondary

        self._readBufPtr +=1
        if self._readBufPtr >= 20:
            self._readBufPtr -= 20
        
        ### DIRECT PATH ###

        # Attenuation due to distance
        att = self._compute_sound_attenuation(d)

        # Attenuation due to air absorption
        filt_coeffs = self.compute_air_absorption_filter(self.airAbsorptionCoefficients, d, numtaps = 10)
        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read1Buf[self._readBufPtr - ii] * filt_coeffs[ii]
        
        # Direct Path Output Sample
        y_dir =  att * sample_eval

        ### REFLECTED PATH ###

        # 1. From Source to Road Surface

        # Attenuation due to distance
        att = self._compute_sound_attenuation(a)
        
        # Attenuation due to air absorption
        filt_coeffs = self.compute_air_absorption_filter(self.airAbsorptionCoefficients, a, numtaps = 10)

        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read2Buf[self._readBufPtr - ii] * filt_coeffs[ii]
        sample_eval = att * sample_eval
        self._read3Buf[self._readBufPtr] = sample_eval

        # 2. Asphalt Absorption
        asphalt_filter_coeffs = self.get_asphalt_reflection_filter(90 - theta, 
            self.asphaltReflectionFilterTable, np.array([-89, 89]))
        
        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read3Buf[self._readBufPtr - ii] * asphalt_filter_coeffs[ii]
        
        
        # 3. Second path in air --> Secondary Delay Line
        y_secondary = self.primaryDelLine.update_delay_line(sample_eval, np.array([tau_2 * self.fs]))
        self._read4Buf[self._readBufPtr] = y_secondary
        # 4. From Road Surface to Receiver

        # Attenuation due to distance
        att = self._compute_sound_attenuation(b)

        # Attenuation due to air absorption
        # alpha = compute_air_absorption_coeffs(T, p_s, hrar, F)
        # alpha = 10 ** (-alpha * drefl / 20)     # Convert coeffs in dB to linear scale
        filt_coeffs = self.compute_air_absorption_filter(self.airAbsorptionCoefficients, b, numtaps = 10)

        sample_eval = 0
        for ii in range(10):
            sample_eval = sample_eval + self._read4Buf[self._readBufPtr - ii] * filt_coeffs[ii]
        y_refl = att * sample_eval

        y_received = y_dir + y_refl

        return y_received
    
    # Compute air absorption FIR filter with ntaps. Depends on distance and air absorption coefficients.
    def compute_air_absorption_filter(self, abs_coeffs: np.ndarray, distance: float, numtaps: int):
        f = np.linspace(0, 11000, num=50)
        norm_freqs = f / max(f)
        alpha = 10 ** (-abs_coeffs * distance / 20)     # Convert coeffs in dB to linear scale
        filt_coeffs = scipy.signal.firwin2(numtaps, norm_freqs, alpha)
        
        return filt_coeffs
    
    # Compute angle dependent asphalt reflection filters for a set of angles [-89,89]deg, with 
    # a resultion of 1deg, based on normal incidence asborption coefficients computed at frequencies freqs.
    # Filters are stored in a table np.array([89*2+1, ntaps]), where ntaps is the desired filter length
    def compute_angle_reflection_table(self, absorption_coeffs: np.ndarray, freqs: np.ndarray, ntaps: int) -> np.ndarray:
        theta_vector = np.arange(-89,89,1)
        Z0 = self.Z0
        refl = np.sqrt(1 - absorption_coeffs)
        Z = - Z0 * (refl + 1) / (refl-1)
        b_fir = np.zeros((len(theta_vector), ntaps))
        
        # Compute filters coefficients for all thetas
        for idx, theta in enumerate(theta_vector):
            # Absolute value is taken to prevent R from going below zero. In Kuttruff, "Acoustics - an Introduction" the modulus of R is used
            # to compute reflections, and with our procedure we are not computing the imaginary part (see Nijl et al. Absorbing surfaces... 2006), 
            # so it is coherent.
            R = np.abs((Z * np.cos(math.radians(theta)) - Z0) / (Z * np.cos(math.radians(theta)) + Z0))
            b_fir[idx] = scipy.signal.firwin2(ntaps, freqs / 4000, R)
        
        return b_fir
    
    def get_asphalt_reflection_filter(self, theta: float, b_fir: np.ndarray, theta_vector: np.ndarray) -> np.ndarray:
        idx = np.where(theta_vector == np.round(theta))
        idx = idx[0][0]
        return b_fir[idx]

    def _compute_sound_attenuation(distance: float) -> float:
        return 1 / (4 * np.pi * distance)
    
    # Computes distance between source and receiver and delay in seconds.
    # Arguments are source position, receiver position and speed of sound in air
    def _compute_delay(self, src_pos, mic_pos, c):
        d = np.sqrt(np.sum((src_pos - mic_pos)) ** 2)
        tau = d / c
        return d, tau
    
    # Compute incidence angle of sound wave on road surface, given source and microphone position
    def _compute_angle(self, src_pos, mic_pos):
        # Distance between image and microphone
        dist = np.sqrt(np.sum(((src_pos - np.array([0, 0 , 2*src_pos[2]]) - mic_pos))) ** 2)
        # Incidence angle
        theta = np.arcsin(dist / (src_pos[2] + mic_pos[2]))
        return theta